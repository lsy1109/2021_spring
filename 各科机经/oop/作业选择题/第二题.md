# 第一题

>  A.一共发生了3次向上类型转换，分别发生在`(1)`，`(2)`，和`(3)`，其中，`(3)`的函数调用`g3(a)`在返回的过程中把`Derive`类的对象`obj`对象切片成`Base`对象

**并非只有带有注释的地方才会做考点**，比如这道题的(2)(3)之间还有一行拷贝构造，这里也会发生向上类型转换，过于考察细心。

------



> B. 一共发生了1次对象切片,发生在`(2)`

注意切片的定义，只有对象发生向上类型转换才是切片，指针和引用都仅仅叫做向上类型转换。故而这句话是对的！

------



> C. `(1)`处`g1(a);`调用的是`Derive::f()`

基类中f不是虚函数，必然只能调用base的f。

------



> D.如果把Derive公有继承Base改成私有继承Base，(1)，(2)处涉及私有继承的向上类型转换，将发生编译错误

只有public继承可以向上类型转换！这句话是对的！

------



# 第二题

> A.`Derive::g()`是`Base::g(int)`和`Base::g(float)`的重载函数

错误，注意三者的区别：

> **重载(overload)：**
>
> 目的：提供同名函数的不同实现，属于静态多态。
>
> 函数名必须相同，函数参数必须不同，作用域相同。（如位于同一个类中；或同名全局函数）
>
>  **重写隐藏(redefining)：**
>
> 目的：在派生类中重新定义基类函数，实现派生类的特殊功能。
>
> 屏蔽了基类的所有其它同名函数。
>
> 如果该函数名在基类里是非虚函数，此时派生类里重新定义的函数无论参数是否相同（这种相同是不考虑默认值的），发生的都是重写隐藏；
>
> 而如果该函数在基类里是虚函数，此时派生类里重新定义的函数如果参数相同，则发生override；如果参数不同，则发生redefining。
>
> **重写覆盖(override)：**
>
>  目的：对基类的虚函数进行重定义，函数名和参数完全相同，返回值一般相同。（如果派生类定义新函数与基类虚函数的函数名相同而参数不同，派生类定义的函数会redefining基类虚函数，发生隐藏而不是覆盖。）
>
> 覆盖的由来：基类虚函数表中的虚函数指针会被派生类中重新定义的同名同参数的虚函数的指针覆盖掉，以此来实现动态绑定。
>
> 
>
> 总结：非虚同名函数在同一个类中发生重载，在不同类（基类和派生类）中发生隐藏。
>
>  虚同名函数，参数相同则在派生类中发生重写覆盖，参数不同则
>
> 在派生类中发生重写隐藏。
>
>
>
>重载：同级调用的优先匹配问题。
>
>  重写隐藏：派生类优先调用派生类同名函数。
>
> 重写覆盖：无论是基类还是派生类的指针，指向派生类对象只能调用派生类同名函数。

显然此题中A是错的。

------




> Derive::g()`重写隐藏`Base::g(int)`和`Base::g(float)

正确！

------



>
> Derive::f1()`重写覆盖`Base::f1()`；`Derive::g()`重写覆盖`Base::g()

前半句话是对的，后面是重写隐藏而非覆盖。

------



> Base::f2()由于被final关键字修饰而不能被重写覆盖，但Derive类中仍然可以定义成员函数void f2()，并重写隐藏Base::f2()

显然不行，这里满足了函数名和参数完全相同，是重写覆盖，但是由于final关键字，故而这么写会error。

------



# 第三题

**善用cppreference。**

> `A.(1)`处调用的是`Base::fn()`，这是因为虚机制在**拷贝构造函数**中不起作用

虚机制在构造函数和析构函数都不起作用。

------



> B. `Derive::g1()`被const修饰，`Base::g1()`没有被const修饰。`Derive::g1()`仍能重写覆盖`Base::g1()`，不会出现编译错误。

这道题非常恶心，查了cppreference，可以看到这里：

> 细节
>
> 若某个成员函数 `vf` 在类 `Base` 中被声明为 `virtual`，且某个直接或间接派生于 `Base` 的类 `Derived` 拥有一个下列几项与之相同的成员函数声明
>
> -  名字
> -  形参列表（但非返回类型）
> -  cv 限定符
> -  引用限定符
>
> 则类 `Derived` 中的此函数亦为*虚*函数（无论其声明中是否使用关键词 `virtual`）并*覆盖* Base::vf（无论其声明中是否使用单词 `override`）。
>
> 要覆盖的 `Base::vf` 不需要可见（可声明为 private，或用私有继承继承）。
>
> 要覆盖的 `Base::vf` 不需要可访问或可见。（ `Base::vf` 能声明为 private ，或者能用私有继承继承 `Base`。 `Derived` 的基类中的任何同名成员不妨碍覆盖确定，即使在名字查找时它们会隐藏 `Base::vf`。）

------

>  C.`Derive::g2()`的返回值为Derive&，`Base::g2()`的返回值为Base&。`Derive::g2()`仍能重写覆盖`Base::g2()`，不会出现编译错误。

返回值是否相同不影响重写覆盖，此处正确。

> D.由于`Base`类析构函数不是虚函数，`(*)`处析构`b`指向的`Derive`类对象时不会调用`Derive`类的析构函数，故存在内存泄漏的问题

基类析构函数一般是虚的，构造函数不能是虚的。



# 第四题

> A. 抽象类必定存在一个成员函数没有函数体

错的！纯虚函数也需要函数体，不过不像其他函数，纯虚函数一定没法在类内定义函数体。以及，哪怕纯虚析构函数也在类外手动定义函数体。

------

> B. 如果在一个抽象类的派生类中将该抽象基类的所有纯虚函数都重写覆盖，则该派生类不再是抽象类 

对的！这是定义。不过纯虚析构函数不需要显示地重写覆盖。

------

> C. 当尝试将派生类对象向上转换为抽象类对象时，会产生编译错误，这是因为抽象类不允许定义对象

对的！

> D. 抽象类不允许有数据成员

允许有数据成员，这样继承后可以使用。但是不允许定义对象。

# 第五题

> A. `dynamic_cast`只能实现引用或指针的向下类型转换，不能实现向上转换。

错，PPT上有些，其实是可以的，但是很少用。

------

> B. 若有`Derive* a = dynamic_cast<Derive*>(pt)`类型转换成功（即a指针不为空），其中`pt`类型为`Base*`，`Derive`类是`Base`类的派生类，则`Base`类一定有虚函数

这就是定义，对的！

> C. 若有`a`是`Base`类的对象，且`Derive`类是`Base`类的派生类，则类型转换`static_cast<Derive>(a)`一定可以成功，运行不会出现错误

在这两中cast里面，不能cast对象。

> D. 对指针和引用进行向下类型转换时，使用`dynamic_cast`比`static_cast`更安全

对的！

# 第六题

A. 一个派生类对象可以继承多个抽象基类

对！

B. 现有`Derive`类是`Base`类的派生类，且`b`是指向`Derive`类对象的`Base`类指针，即使派生类`Derive`重写覆盖了基类`Base`的一个虚函数`void fn();`，仍然可以通过`b->Base::fn()`调用`Base::fn()`

对！重写隐藏和覆盖都可以。

C. 在类的析构函数中调用虚成员函数，被调用的是该函数的本地版本

析构和构造函数都是调用本地版本。

> D. 如果派生类保护继承或私有继承基类，则基类的虚成员函数将不能被重写覆盖

这句话是错的，PPT上没有，还是查cppreference。

> 要覆盖的 `Base::vf` 不需要可见（可声明为 private，或用私有继承继承）。
>
> 要覆盖的 `Base::vf` 不需要可访问或可见。（ `Base::vf` 能声明为 private ，或者能用私有继承继承 `Base`。 `Derived` 的基类中的任何同名成员不妨碍覆盖确定，即使在名字查找时它们会隐藏 `Base::vf`。）

# 第七题

关于多态，以下说法正确的有：

> A. 对象、指针、引用对虚函数的调用总是晚绑定，即运行时绑定

对象不是晚绑定，且引用和指针也只是对虚函数才晚绑定。

> B. 多态可以提高代码接口的复用性
>
> C. C++语言编译时的多态性可通过函数重载或模板实现

对的！

> D. 若派生类`Derive`重写覆盖基类`Base`的一个虚函数`void fn();`，且`Derive`类对象`d`通过对象切片的方式转换成`Base`类对象`b`，因为虚函数的多态性，`b.fn()`将调用`Derive::fn()`

对象没有多态性！



# 第八题

考试直接拿去跑一跑就好了。

> A. `(2)`处`A::get()`的定义采用的类型名`T1`与`(1)`处类`A`采用的类型名`T0`不同，因此编译错误

并不会，参数名字不影响。

> B. 程序的执行结果为`4.3\n8\n`

跑一跑，是对的！

> C. **根据函数模板`sum`的定义**，实参类型需要定义成员函数`get`，且`sum`的返回值类型必定与参数类型不同

这里完全可以T0=T1。

> D. 如果`(3)`处添加代码`sum(9, 2);`，程序依然能正常编译运行

不行，因为没法对整数定义get()。
