# 关键路径

## 建模

###    PT图

- 结点表示工序
 - 有向边$(i , j )$表示工序 $i $完成之后工序$ j$才能启动
 - 边权$wi $表示工序$ i $所需的时间



### PERT图

- 结点为工序之间的关系
 - $v_k $同时是是$e_i$的终点、$e_j $的始点则表示工序$e_i$完成后$e_j$才能开始
 - 有向边表示工序
 - 边权$w_i$表示该工序所需时间

------

## 算法


关键路径就是找到PT图（一定是有向图）中，从起始点（第一个工序）到中止点（最后一个工序）的**最长路**，此路径称为关键路径。

- 所有不需要先行工序的点都是起始点，不是任何工序的先行工序的点都是终止点。
- 如果有多个起始点：设置虚拟起始点，这个点到所有真正起始点有有向边，边权是0。
- 如果有多个中止点：设置虚拟中止点，所有真正中止点指向这个虚拟点，且边权是完成这些工序花费的时间（最后一道工序是需要花费时间的）。
- 问题转化为求唯一起始点到唯一中止点的最长路径。



### top sort

- 引理2.7.1：有向图$G$无有向回路，则一定存在入度及出度为0的结点，且这两个节点不一定是同一个点。(如果没有孤立点，必然不是同一个节点。)
- PT图必然不含有向回路。（实际意义）
- 若有向图$G$无有向回路，则可以将$G $的结点重新编号为$v_1’, v_2’, …, v_n’,$使得对任意的边$(v_i’ ,v_j’) ∈E(G),$都有$i＜ j $，即图中所有边都是从编号小的结点指向编号大的结点。
- 设$G=(V,E)$是一个具有$n$个顶点的有向图,$V$中顶点序列$v_1, v_2, …, v_n$称为一个**拓扑序列**,当且仅当该顶点序列满足下列条件：若$<v_i,v_j>$是图中的边(即从顶点$v_i$到$v_j$有一条路径),则在序列中顶点$v_i $必须排在顶点$v_j$之前。
- 在一个有向图中找一个拓扑序列的过程称为拓扑排序。
- 有且仅有**没有有向回路的有向图**可以top sort.



### algorithm of top sort

1.  从有向图中选择一个没有前驱(即入度为0)的顶点给他标号。
2. 从图中删去该顶点，并且删去从该顶点发出的全部有向边。
3. 重复上述两步，直到剩余的图中不再存在没有前驱的顶点为止。
- 如果还有顶点却没有入度为0的顶点，说明有向图有环存在。
- top排序完了之后要**保留原来节点的标号**，因为输出关键路径是**按照原来的节点输出**。
- 该算法的复杂度为$O(m)$.



### 循环计算

节点重新编号后，设从$v_1$出发到各个顶点的最长路径，也就是各个工序的最早启动时间分别为$\pi(1)$、$\pi(2)…\pi(n)$，那么$\pi(1)=0$，且$\large\color{blue}{\pi(j) = max_{0<i<j} {\pi(i) + l_{ij}}} $

更新每一个节点后，保留$\pi(i)$，用于之后计算延误。

更新每一个点的时候，只需要遍历这个点的所有直接前驱，不必遍历一次所有编号比这个点小的所有点。

拓扑排序的作用：确保更新每个点的时候，其前驱的$\pi$值都已经更新完毕了。



### 延误问题

- 所有长度一样的最长道路都是关键路径，这几条路上面的点都是关键节点，不能延误。
- 如果存在多条关键路径，则他们在交点处用时必然相同，只有全都按时完成，才能不延误之后的任务。
- 对于非关键路径上的点，所有点都要被执行，只不过这些点可以延误。



可延误时间=最晚启动时间-最早启动时间，即$t(v)=\tau(v)-\pi(v)$



### 最晚启动时间算法

按照之前的top编号，先算出所有的$\pi(i)$，并赋初值$\tau(i)=\pi(i)$，**从后往前**，依次迭代：

$\large\color{blue}{\tau(v)=min_{j\in \Gamma ^{+}_i}(\tau(j)-l_{ij})}$



这里只给出了最方便计算的算法——**从后往前迭代，求(直接后续-路径长度)的最小值**。还有一种不太优化的理解与算法——**从前往后迭代，求中间节点到终点的关键路径**，这个算法不太优化，因为每次都要重走关键路径。



1. 计算启动最早时间是以第一道工序为参考，规定其开始时间为0。

2. 计算最晚时间是以最后一道工序做参考，规定其结束时间为$\tau(end)=\pi(end)$（这个值由过程(1)算出，在算最晚启动时间时只是个定值)。

3. 起始点的最晚启动时间也一定是0，否则是计算错误。

   

------



# 中国邮路

## 区别四种路

- **欧拉**：通过每条边且仅一次。
- **中国邮路**： 经过每条边**至少**一次最后返回到出发点的最短路径。
- **哈密顿**：通过每个节点一次且仅一次。
- **旅行商**：经过每个节点一次最后返回到出发点的最短路径。
- 旅行商可以看做最短的哈密顿回路，中国邮路可以看为最短的欧拉回路。
- 一个欧拉图对不同起点的欧拉回路的长度必定相等，但是实际上的图可能不是欧拉图。故而中国邮路问题转化为找出某几条边，将他们加倍，然后形成欧拉图，并且这几条边要权值和最小。
- 术语描述：求$E_1\subseteq E$满足条件: 在G中重复$E_1$中每条边, 使得到的图$G^*$是$Euler$图(称这样的$E_1$为可行集)，并且使其边权和尽可能小(称这样的可行集$E_1$为最优集)。之后求$G^*$的Euler回路。



## 欧拉图判定

- 欧拉图都是连通图。
- 无向图：充要条件是各顶点的度都是偶数。
- 有向图：各点正负度相同，则存在有向欧拉回路。




**握手定理**决定图中的奇点必须为偶数个。

**两奇点欧拉问题**：若无向连通图G中只有两个奇顶点，添上一条线后，构成欧拉回路。去掉之后则G存在欧拉道路。



## 中国邮路算法

**中国邮路的充要条件：**

1. G的每条边最多重复一次。
2. 在G的任意一个回路上, 重复边的长度之和不超过该回路长度的一半。



**无向图中国邮路：**

1. 找出度为奇的点。
2. 依据条件1构造邮路，即G的每条边最多重复一次，并保证计算重复边之后度都是偶数。
3. 由条件2对所有回路进行判断，在G的任意一个回路上,如果重复边的长度之和超过该回路长度的一半，则令回路中的重复边不重复，不重复边变为重复。
4. 注意到，这样找出来的中国邮路当然不止一个，但是我们能证明这些路径都符合条件，也就是**他们对应的欧拉回路长度相等**。



还有**Edmonds最小权匹配算法**，但是没讲的算法不考。



**有向图中国邮路：**

-   有向图可能没有中国邮路。
- 当图中含有正度或负度为0的点时，没有中国邮路。比如，如果v点出度为0，则“进入”v点之后无法找到路“出来”。
- 若图中各点正负度相同，则存在有向欧拉回路，任一条欧拉回路都是问题的解。



有向图中，**存在正负度数不等**的节点时：

- 如果$d'(i)=d(i)^+-d(i)^->0$，需要多进入这个节点$d'(i)$次，重复经过$d'(i)$次进入$v_i$的边。
- 如果$d'(i)=d(i)^+-d(i)^-<0$，需要多离开这个节点$d'(i)$次，重复经过$d'(i)$次从$v_i$发出的边。
- $d'(i)=d(i)^+-d(i)^-=0$的节点为中间节点。
- 我们对所有$d'(i)\ne 0$的节点进行配对。



**构造方法：**

-  计算各点的正负度，求出$d’(v_i)=d^+(v_i)–d^-(v_i)$
- 添加一个超收点$v_s$，对满足$d’(v_i)>0$的结点，加入$d’(v_i)$条有向边$(v_i, v_s)$，权为0。 
- 添加一个超发点$v_t$ ，对满足$d’(v_j)<0$的结点，加入$d’(v_j)$条有向边$(v_t ,v_j)$，权为0。
- 在$G’$中求$d(v_s)$条过以$v_t, v_s$为两端点的形如$(v_t, v_j)……(v_i, v_s)$，最多经过G中某条边一次，且总和最小的$P_{ts}$有向道路。记下$G$中各边在这些道路里的重复次数。
- 计入各边的重复次数，$G$中存在有向欧拉回路，其中任何一条即为解。

